{"title":"CPU硬件架构解析","uid":"fd66792a70b4a45f7bd145438a8832e0","slug":"CPU硬件架构解析","date":"2025-08-10T10:18:29.000Z","updated":"2025-08-10T10:22:30.725Z","comments":true,"path":"api/articles/CPU硬件架构解析.json","keywords":null,"cover":[],"content":"<h2 id=\"1-引言\"><a href=\"#1-引言\" class=\"headerlink\" title=\"1.引言\"></a>1.引言</h2><p>《Processor Microarchitecture An Implementation Perspective》</p>\n<p>链接：<a href=\"https://dl.icdst.org/pdfs/files/15b09def448c317556dc0fc412aee571.pdf\">https://dl.icdst.org/pdfs/files/15b09def448c317556dc0fc412aee571.pdf</a></p>\n<p>处理器微架构演进主要源自两个因素：</p>\n<ul>\n<li><p>technology scaling</p>\n</li>\n<li><p>workload evolution</p>\n</li>\n</ul>\n<p>###1.1 Moore’s Law</p>\n<ul>\n<li>Moore, Gordon E. (1965). “Cramming more components onto integrated circuits” (PDF). Electronics Magazine. pp. 4.<ul>\n<li>“The complexity for minimum component costs has increased at a rate of roughly a factor of two per year.”</li>\n<li>Moore refined it to “every two years” in 1975</li>\n<li>Also quoted as “every 18 months” by David House, (referring to performance)</li>\n<li>Most popular formulation: #transistors&#x2F;IC</li>\n</ul>\n</li>\n<li>Carver Mead coined it as Moore’s law around 1970<ul>\n<li>– “Tall &amp; Thin engineers”</li>\n</ul>\n</li>\n<li>Ultimate limit of Moore’s Law<ul>\n<li>No one knows</li>\n<li>How to use the capability? Resource limit?</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"1-2-CPU微体系结构\"><a href=\"#1-2-CPU微体系结构\" class=\"headerlink\" title=\"1.2 CPU微体系结构\"></a>1.2 CPU微体系结构</h3><h4 id=\"1-2-1-微架构分类\"><a href=\"#1-2-1-微架构分类\" class=\"headerlink\" title=\"1.2.1 微架构分类\"></a>1.2.1 微架构分类</h4><p>按照一些相互正交的维度进行分类：</p>\n<ol>\n<li><p>Pipelined&#x2F;Nonpipelined Processors</p>\n<p>Pipelined提高了ILP，并且由于成本效益好，几乎所有的处理器都采用</p>\n</li>\n<li><p>In-Order&#x2F;Out-of-Order Processors</p>\n<p>Out-of-Order 需要更复杂的硬件设计，在乱序执行中，指令可以不按程序指定的顺序执行，减少阻塞，但对外表现的行为还是和顺序执行的处理器一样；</p>\n</li>\n<li><p>Scalar&#x2F;Superscalar Processors </p>\n<p>标量和超标量处理器，标量处理器的 IPC 最多为 1，因为只有一套执行单元，而不是标量处理器的就是超标量处理器，IPC 可以大于 1。</p>\n</li>\n<li><p>Vector Processors</p>\n<p>向量处理器可以使用一条向量指令处理多个元素的向量，也就是 SIMD，例如 Intel 的 AVX 指令就是 SIMD 指令；</p>\n</li>\n<li><p>Multicore Processors</p>\n<p>是否多核？多核处理器中每一个核心的硬件资源相对独立不共享</p>\n</li>\n<li><p>Multithreaded Processors</p>\n<p>是否多线程？多线程中的线程通常共用大部分的硬件资源</p>\n</li>\n</ol>\n<p><strong>流水线技术</strong></p>\n<p>![image-20250724163845529](&#x2F;Users&#x2F;rockyliu&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20250724163845529.png)</p>\n<p>一条指令的生命周期分为五个阶段：</p>\n<p>取指（IF）——&gt;译码（ID）——&gt;重命名 &amp; 分发——&gt;执行（EXE）——&gt;访存（MEM）——&gt;写回（WB）</p>\n<p>《从入门到放弃：CPU流水线技术全解析》<a href=\"https://juejin.cn/post/7401417746541068297\">https://juejin.cn/post/7401417746541068297</a></p>\n<p>将访存单独作为一个阶段的考虑：</p>\n<ul>\n<li><p>假设访存延迟为0周期，即理想寄存器</p>\n</li>\n<li><p>地址计算（加法器）的路径和访存路径加起来太长</p>\n<ul>\n<li>拆分为两个阶段更均衡</li>\n</ul>\n<p>但在实际的处理器设计中, 上述假设不再成立</p>\n<p>访存操作一般需要多个周期；</p>\n<p>cache: 缓存的控制逻辑是个状态机；即使命中，状态机也需要经过若干个周期的控制才能读出数据</p>\n<p>访存路径上有很多地址寄存器，地址计算的延迟和资源开销并不明显</p>\n</li>\n</ul>\n<h4 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h4><p><a href=\"https://xiaofeng.info//presentations/history_Intel_CPU.pdf\">https://xiaofeng.info//presentations/history_Intel_CPU.pdf</a></p>\n<p><a href=\"https://www.agner.org/optimize/microarchitecture.pdf\">https://www.agner.org/optimize/microarchitecture.pdf</a></p>\n<p><a href=\"https://www.mindshare.com/eLearning/Course/Intel_x86_Processor_and_Platform_Architecture_eLearning_Course\">https://www.mindshare.com/eLearning/Course/Intel_x86_Processor_and_Platform_Architecture_eLearning_Course</a></p>\n<p>• Intel x86 CPU and Chipset Evolution<br>• Current Core and Xeon CPUs: Ice Lake, Cascade Lake, plus “Refresh” Variants<br>• X86 Instruction Set Architecture (ISA) and CPU Operating Modes<br>• Core and Xeon CPU Microarchitecture Differences<br>• Caches<br>• Platform Addressing<br>• Main Memory DRAM<br>• Ultra Path Interconnect (UPI)<br>• CPU Integrated Graphics<br>• CPU Integrated IO (IIO)<br>• Interrupt Handling<br>• Hardware Virtualization Support<br>• Platform Controller Hub (PCH) Features<br>• Power and Thermal Management<br>• CPU Performance Monitoring</p>\n<p><a href=\"https://cdrdv2-public.intel.com/786255/786255_330119_ia-introduction-basics-paper.pdf\">https://cdrdv2-public.intel.com/786255/786255_330119_ia-introduction-basics-paper.pdf</a></p>\n<p><a href=\"https://www.mindshare.com/files/ebooks/x86%20instruction%20set%20architecture.pdf\">https://www.mindshare.com/files/ebooks/x86%20instruction%20set%20architecture.pdf</a></p>\n<h2 id=\"2-X86\"><a href=\"#2-X86\" class=\"headerlink\" title=\"2.X86\"></a>2.X86</h2><h3 id=\"2-1-Intel\"><a href=\"#2-1-Intel\" class=\"headerlink\" title=\"2.1 Intel\"></a>2.1 Intel</h3><h4 id=\"2-1-1-产品路标演进\"><a href=\"#2-1-1-产品路标演进\" class=\"headerlink\" title=\"2.1.1 产品路标演进\"></a>2.1.1 产品路标演进</h4><p>Intel x86 Core and Xeon Platform Background<br>o Intel 64 and IA-32 CPU lineage<br>§ 80386 to Ice Lake&#x2F;Cascade Lake<br>§ Core and Xeon CPUs Expected Next<br>o Ice Lake&#x2F;Cascade Lake Platform Examples<br>§ Gaming Desktop<br>§ 2-in-1 Laptop<br>§ Xeon Scalable CPU Server</p>\n<p>X86 Instruction Set Architecture (ISA)<br>o CPU Core Fetch&#x2F;Decode&#x2F;Execute Role<br>o X86 Instruction Basics<br>o Instruction Set Overview<br>§ General Purpose Instructions<br>§ Floating Point and SIMD Instructions<br>§ Program Flow Instructions<br>§ Hardware-Related Instructions<br>o X86 Register Set Overview<br>§ General Purpose Registers (GPRs)<br>§ X87&#x2F;MMX Registers<br>§ XMM&#x2F;YMM&#x2F;ZMM Registers<br>§ Segmentation Registers<br>§ Control Registers<br>§ Debug Registers<br>§ Model-Specific Registers (MSRs)<br>o X86 CPU Operating Modes<br>§ Real Mode<br>§ Protected Mode<br>§ Virtual-8086 Mode<br>§ System-Management Mode (SMM)<br>§ IA32e (Long) Mode</p>\n<p>![image-20250724114810496](&#x2F;Users&#x2F;rockyliu&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20250724114810496.png)</p>\n<p>典型的Dual-socket systems</p>\n<p><img src=\"https://intelcorp.scene7.com/is/image/intelcorp/purley-2s-configuration-block-diagram-16x9:1920-1080?wid=978&hei=550&fmt=webp-alpha\" alt=\"Intel® Xeon® Processor Scalable Family Block Diagram: 2S Configuration\"></p>\n<h4 id=\"2-1-2-NUMA-架构\"><a href=\"#2-1-2-NUMA-架构\" class=\"headerlink\" title=\"2.1.2 NUMA 架构\"></a>2.1.2 NUMA 架构</h4><p><strong>Uniform Memory Access Domain</strong></p>\n<p><img src=\"https://www.intel.com/content/dam/developer/articles/technical/fourth-generation-xeon-scalable-family-overview/spr-uma.png\" alt=\"img\"></p>\n<p> <strong>Sub-NUMA Clustering</strong></p>\n<p><img src=\"https://www.intel.com/content/dam/developer/articles/technical/fourth-generation-xeon-scalable-family-overview/spr-2-snc.png\" alt=\"img\"></p>\n<p>​                       Figure 2 – Block Diagram Representing Domains Of sub-NUMA With Two Clusters</p>\n<p><img src=\"https://www.intel.com/content/dam/developer/articles/technical/fourth-generation-xeon-scalable-family-overview/spr-4-snc.png\" alt=\"img\"></p>\n<p>​                         Figure 3 – Block Diagram Representing Domains Of sub-NUMA With Four Clusters</p>\n<h3 id=\"2-2-AMD\"><a href=\"#2-2-AMD\" class=\"headerlink\" title=\"2.2 AMD\"></a>2.2 AMD</h3><h4 id=\"2-2-1-架构演进\"><a href=\"#2-2-1-架构演进\" class=\"headerlink\" title=\"2.2.1 架构演进\"></a>2.2.1 架构演进</h4><p>![AMD CPU架构](&#x2F;Users&#x2F;rockyliu&#x2F;Documents&#x2F;技术宝典&#x2F;CPU&#x2F;X86&#x2F;AMD CPU架构.png)</p>\n<p>AMD EPYC 9004系列</p>\n<p>![image-20250723150813290](&#x2F;Users&#x2F;rockyliu&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20250723150813290.png)</p>\n<p><img src=\"/Users/rockyliu/Documents/%E6%8A%80%E6%9C%AF%E5%AE%9D%E5%85%B8/CPU/X86/AMD-9654.png\" alt=\"AMD-9654\"></p>\n<p> 5TH GEN AMD EPYC™ PROCESSOR ARCHITECTURE</p>\n<p><a href=\"https://www.amd.com/content/dam/amd/en/documents/epyc-business-docs/white-papers/5th-gen-amd-epyc-processor-architecture-white-paper.pdf\">https://www.amd.com/content/dam/amd/en/documents/epyc-business-docs/white-papers/5th-gen-amd-epyc-processor-architecture-white-paper.pdf</a><br> I&#x2F;O DIE FEATURES</p>\n<p>![AMD-I:O die](&#x2F;Users&#x2F;rockyliu&#x2F;Documents&#x2F;技术宝典&#x2F;CPU&#x2F;X86&#x2F;AMD-I:O die.png)</p>\n<p>When three links between processors are used, an additional 16 PCIe lanes on each CPU are available for general I&#x2F;O, bringing the total I&#x2F;O capacity up to 160 lanes. When four links are configured, they can support a maximum theoretical bandwidth of 512 GB&#x2F;s between processors.</p>\n<ol>\n<li>当双路CPU使用G-links * 3 （48 Lanes）时，另外的16 PCIe lanes 可以用于标准I&#x2F;O，总的I&#x2F;O能力扩展到160 lanes;</li>\n<li>当双路CPU使用G-links * 4 （64 Lanes）时，CPU间支持最大双向理论带宽512GB&#x2F;s。</li>\n</ol>\n<p><img src=\"/Users/rockyliu/Documents/%E6%8A%80%E6%9C%AF%E5%AE%9D%E5%85%B8/CPU/X86/Genoa.png\" alt=\"Genoa\"></p>\n<p>Non-Uniform Memory Access (NUMA) architecture </p>\n<ul>\n<li>Different latencies</li>\n</ul>\n<p>​       depending on the proximity of a processor core to memory and I&#x2F;O controllers</p>\n<ul>\n<li>Same NUMA node provides uniform good performance,while use resources in differing nodes increases latencies.</li>\n</ul>\n<p>NUMA Setting </p>\n<p>NUMA Nodes Per Socket (NPSx)<br>• NPS4: Four NUMA nodes per socket, one per quadrant.<br>  o Requires symmetrical CCD configuration across all quadrants of the SoC.<br>  o Preferred Interleaving: 2-channel interleaving using channels from each quadrant.<br>• NPS2: Two NUMA nodes per socket, one per left&#x2F;right half of the SoC.<br>  o Requires symmetrical CCD configuration across left&#x2F;right halves of the SoC.<br>  o Preferred Interleaving: 4-channel interleaving using channels from each half.<br>• NPS1: One NUMA node per socket.<br>  o Available for any CCD configuration in the SoC.<br>  o Preferred Interleaving: 8-channel interleaving using all channels in the socket.<br>• NPS0: One NUMA node per system.<br>  o Available only on a 2P system.<br>  o Preferred Interleaving: 16-channel interleaving using all channels in the system.<br>Note: If the CCD configuration is altered by software (e.g., BIOS Setup Option), NPS4 and NSP2<br>options may not be available based on the Symmetry requirements noted above.</p>\n<p><img src=\"/Users/rockyliu/Documents/%E6%8A%80%E6%9C%AF%E5%AE%9D%E5%85%B8/CPU/X86/NPS1.png\" alt=\"NPS1\"></p>\n<p>![image-20250723175300806](&#x2F;Users&#x2F;rockyliu&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20250723175300806.png)</p>\n<p>![image-20250723175400320](&#x2F;Users&#x2F;rockyliu&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20250723175400320.png)</p>\n<p>![image-20250723175602458](&#x2F;Users&#x2F;rockyliu&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20250723175602458.png)</p>\n<p>![image-20250723175515519](&#x2F;Users&#x2F;rockyliu&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20250723175515519.png)</p>\n<p>引发问题？</p>\n<p>   1.NUMA是个好东西，为啥有的业务场景抗拒开启NPS？</p>\n<ul>\n<li><p>跨NUMA分配CPU导致远程访问性能损耗，出现性能分层</p>\n</li>\n<li><p>不同业务间共享核导致Cache频繁加载、互相污染开销增加，可用性和延时增加</p>\n</li>\n<li><p>不同优先级和不同资源敏感程度 业务pod在节点上数量分配不均衡，导致竞争开销</p>\n</li>\n<li><p>节点上其他资源的竞争（IO、网络、内存）</p>\n<p> 2.开启NPS后会增加Latency,会造成哪些影响？如何进行性能调优？</p>\n</li>\n</ul>\n<p>Infinity Fabric links</p>\n<p> External Global Memory Interconnect [xGMI] links </p>\n<ul>\n<li>Dual-socket systems</li>\n</ul>\n<p>​       4 xGMI ：4x16&#x3D;64 PCIe lanes from each socket for Infinity Fabric connections.  leave 64 PCIe lanes each socket&#x3D; 64x2&#x3D;128 lanes </p>\n<p>​       3 xGMI :  In these cases, 160 lanes for PCIe (80 per socket) </p>\n<h3 id=\"2-3-Chiplet技术\"><a href=\"#2-3-Chiplet技术\" class=\"headerlink\" title=\"2.3 Chiplet技术\"></a>2.3 Chiplet技术</h3><p>​\t<a href=\"https://zhuanlan.zhihu.com/p/604721264\">Chiplet</a> 即小芯粒，它将一类满足特定功能的 die（裸片），通过 die-to-die 内部互联技术将多个模块芯片与底层基础芯片封装在一起，形成一个系统芯片。</p>\n<img src=\"/Users/rockyliu/Documents/image-20250805145129441.png\" alt=\"image-20250805145129441\" style=\"zoom:80%;\" />\n\n<ul>\n<li><p>大面积芯片降低成本提升良率</p>\n<p>随着先进制程推进，研发成本持续走高。Chiplet 将单颗 SOC 的不同功能模块拆分成独立的小芯粒（即 Chiplet）， 大大缩小了单颗 die 的面积，起到提升良率、降低成本的作用。</p>\n</li>\n<li><p>小芯片模块化，实现IP复用，加速芯片迭代</p>\n</li>\n<li><p>Die to die的高速互联（载板或者Interposer互联）“堆料“</p>\n<p>Interposer 的材质又分为硅基、有机两种。若芯片是平铺在 封装的衬底上，则称为 2.5D 封装，若是芯片之间堆叠封装，则称为 3D 封装。</p>\n<p>![image-20250805145518266](&#x2F;Users&#x2F;rockyliu&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;2.5D:3D封装.png)</p>\n<p>芯片厂可以将多颗计算核心die进行合封，提高芯片整体性能。</p>\n</li>\n</ul>\n<h2 id=\"3-ARM\"><a href=\"#3-ARM\" class=\"headerlink\" title=\"3.ARM\"></a>3.ARM</h2><h3 id=\"3-1-硬件架构\"><a href=\"#3-1-硬件架构\" class=\"headerlink\" title=\"3.1 硬件架构\"></a>3.1 硬件架构</h3><p>《Kunpeng 920: The First 7-nm Chiplet-Based 64-Core ARM SoC for Cloud Services》</p>\n<p>链接：<a href=\"https://ieeexplore.ieee.org/document/9444893\">https://ieeexplore.ieee.org/document/9444893</a></p>\n<p>知乎解读：<a href=\"https://zhuanlan.zhihu.com/p/654058158\">https://zhuanlan.zhihu.com/p/654058158</a></p>\n<p>Kunpeng 920 采用乐高式架构设计。</p>\n<p>![image-20250725160244189](&#x2F;Users&#x2F;rockyliu&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20250725160244189.png)</p>\n<p>双路使用huawei的Hydra，接口提供24-lane的SerDes</p>\n<p>![image-20250725160326915](&#x2F;Users&#x2F;rockyliu&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20250725160326915.png)</p>\n<h4 id=\"3-1-1-芯片组件\"><a href=\"#3-1-1-芯片组件\" class=\"headerlink\" title=\"3.1.1 芯片组件\"></a>3.1.1 芯片组件</h4><p>![image-20250724201151569](&#x2F;Users&#x2F;rockyliu&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20250724201151569.png)</p>\n<h4 id=\"3-1-2-组件单元\"><a href=\"#3-1-2-组件单元\" class=\"headerlink\" title=\"3.1.2 组件单元\"></a>3.1.2 组件单元</h4><ul>\n<li><p>片上总线：Cache一致性总线 Hydra接口级联</p>\n</li>\n<li><p>CCL：内核集群</p>\n<p>华为鲲鹏920的每个内核集群（CCL）都由4个内核和专用L2 Cache组成。华为鲲鹏920的CCL之间支持完全一致性。总线上的其他功能单元可以一致性地访问每个CCL的缓存中的最新数据。</p>\n</li>\n</ul>\n<p>![image-20250725151018554](&#x2F;Users&#x2F;rockyliu&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20250725151018554.png)</p>\n<ul>\n<li>ICL：I&#x2F;O集群</li>\n</ul>\n<p>![image-20250725151216449](&#x2F;Users&#x2F;rockyliu&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20250725151216449.png)</p>\n<p>一个典型的ICL包括以下组成部分：</p>\n<ol>\n<li>多个设备（如图2-9所示）；</li>\n<li>0个或1个SMMU（System Memory Management System），为设备提供地址转换和访问保护功能；</li>\n<li>1个系统总线接口</li>\n<li>1个Sysctrl或Subctrl，用于固件初始化和公共配置；</li>\n<li>1个Dispatch，为访问设备寄存器空间提供物理地址（PA）译码；</li>\n<li>0个或多个Scheduler，当设备数量较多时，Scheduler可以合并各设备的内存访问流量。</li>\n</ol>\n<ul>\n<li><p>SCCL：超级内核集群</p>\n<p>华为鲲鹏920的每个SCCL包括6个CCL、2个ICL和4个DDR控制器。DDR控制器也可以看做一个设备。SCCL内部结构如图2-10所示。</p>\n<p>![image-20250725152900850](&#x2F;Users&#x2F;rockyliu&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20250725152900850.png)</p>\n</li>\n<li><p>SICL：供超级I&#x2F;O集群</p>\n<p>每个SICL由4个ICL、1个Hydra接口和1个独立的IMU组成。</p>\n<p>![image-20250725152955168](&#x2F;Users&#x2F;rockyliu&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20250725152955168.png)</p>\n</li>\n</ul>\n<p>3.2 内存子系统</p>\n<p>![image-20250725153128420](&#x2F;Users&#x2F;rockyliu&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20250725153128420.png)</p>\n<h2 id=\"4-性能分析\"><a href=\"#4-性能分析\" class=\"headerlink\" title=\"4.性能分析\"></a>4.性能分析</h2><h3 id=\"4-1-前置知识\"><a href=\"#4-1-前置知识\" class=\"headerlink\" title=\"4.1 前置知识\"></a>4.1 前置知识</h3><ol>\n<li><p>熟悉CPU硬件，关注微架构级别的硬件演进和主流CPU演进：</p>\n<p>a. X86 (Intel &amp; AMD)、ARM（Kunpeng）等主流CPU厂商产品：</p>\n<p>i. 基本参数</p>\n<p> ii. 微架构设计 </p>\n<p>iii. 各级（core、uncle、offcore）PMC含义、获取和应用方式（关键指标计算）</p>\n<p>b. CPU体系结构</p>\n<p>i. CPU流水线技术</p>\n<p>ii. 理解CPU的页表机制、预取机制；</p>\n<p>iii. 流水线+超标量+多发射技术如何并行执行指令提高效率</p>\n<p>iv. 理解分支预测、</p>\n<p>v. 内存组件的技术细节</p>\n<p>vi. PCIe组件技术细节</p>\n</li>\n<li><p>了解Linux内核个和相应分析工具</p>\n<p>a.熟悉Linux 进程和线程管理和调度</p>\n<p>b. 掌握Linux的性能分析与调优方法，能够进行函数级问题定位；</p>\n<p>i. 熟练使用 FlameGraph、perf、Prometheus等工具；</p>\n<p>ii. Pstack.      Gdb  attach </p>\n<p>iii. Ebpf工具、bpftrace 进行内核路径trace</p>\n</li>\n<li><p>了解公司业务的性能画像,能够通过Specint等Benchmark评估硬件性能：</p>\n<p>a. 熟悉各类服务器性能指标的含义和获取方式,并据此评估业务性能需求；</p>\n<p>i. 硬件上:CPU利用率、IPC、各级cache&#x2F;TLBmiss率、branch和branchmiss数、内存占用、内存带宽、内存延迟、UPI&#x2F;xGMI带宽、TMA指标、网卡带宽;</p>\n<p>ii. 软件上:CPUuser&#x2F;sys&#x2F;软&#x2F;硬中断利用率占比、整机load、网卡丢包、上下文切换次数;</p>\n<p>b.理解各项基本单元测试的目的、方法,能够正确评估测试结果反映的性能水平：</p>\n<p>  i. 不同读写比例下的随机读写内存带宽-时延曲线;</p>\n<p>  ii. 原子操作的指令开销;</p>\n<p>  iii .Specint的各子项负载的工作pattern和性能需求;</p>\n<p>c.掌握常见性能优化方式,帮助提高业务性能:</p>\n<p>  i. 正确使用大页内存、透明大页;</p>\n<p>  ii. 合理绑核,合理配置实例线程数量&#x2F;内存大小;</p>\n<p>  iii. 正确配置网络相关参数(网卡队列数量、大小、中断绑核、网卡PCle配置);</p>\n</li>\n</ol>\n<h3 id=\"4-2-分析思路\"><a href=\"#4-2-分析思路\" class=\"headerlink\" title=\"4.2 分析思路\"></a>4.2 分析思路</h3><p><a href=\"https://zh.wikipedia.org/wiki/%E6%9C%A8%E6%A1%B6%E7%90%86%E8%AB%96\">木桶效应</a></p>\n<p>首先要识别性能瓶颈，通过监控测量分析定位性能瓶颈，才能结合场景对症下药（理解工作原理）</p>\n<p>在分析过程中要明确关注哪些性能指标，这个是性能分析的关键：</p>\n<ul>\n<li><p>微架构分析Microarchitecture analysis ：CPU内部瓶颈（bottlenecks）</p>\n</li>\n<li><p>锁分析Lock analysis：锁竞争和等待时间</p>\n</li>\n<li><p>IO分析：IO操作瓶颈</p>\n</li>\n<li><p>调度分析：由于调度产生的瓶颈</p>\n</li>\n<li><p>CPU限制分析：识别由于CPU竞争导致的瓶颈</p>\n</li>\n<li><p>内存边界分析：内存碎片、内存总线限制</p>\n</li>\n</ul>\n<p>微架构分析：</p>\n<p>​\t现代CPU通常采用五级流水，通常包含五个执行阶段。每条指令可以分解为与流水线阶段对应的微操作：IF、ID、EXEC、MEM 和 WB。</p>\n<p><img src=\"https://miro.medium.com/v2/resize:fit:700/1*R2swNw346XPUM3fwbnAKBw.png\" alt=\"img\"></p>\n<p>可以使用<code>perf stat</code>命令来检查：</p>\n<p><img src=\"https://miro.medium.com/v2/resize:fit:640/format:webp/1*KMwBdGSYyB6F64mof-O7Lw.png\"></p>\n<p>每个指令周期的指令数越多，应用程序可以完成的工作就越多。</p>\n<p>​\t</p>\n<p><strong>CPU数据缓存分析</strong></p>\n<p>CPU数据缓存分析可以通过<code>perf stat -e L1-dcache-load-misses,L1-dcache-loads</code>来验证。</p>\n<p><strong>CPU分支预测分析</strong></p>\n<p>CPU <a href=\"https://blog.cloudflare.com/branch-predictor/\">分支预测</a>的指标可以通过 来检查<code>perf stat -e branches,branch-misses</code></p>\n<p>TLB 缓存和 FLOPS 是潜在的瓶颈。CPU 通常将虚拟地址到物理地址的转换缓存在 TLB 中。当 TLB 缓存未命中时，CPU 需要遍历内核页表，根据引用的虚拟地址计算物理地址。这个过程非常耗时。使用大页可以减轻 TLB 的压力。</p>\n<p>Flame graphs 火焰图 </p>\n<p>IPC和CPU频率的关系</p>\n<p>由于 IPC是衡量微架构性能优劣的指标</p>\n<p>内存密集型应用程序通常以低 IPC (0-1) 为特征，而计算密集型工作负载往往具有高 IPC (4-6)。</p>\n<p>Linux perf 用户可以通过运行以下命令测量其工作负载的 IPC：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">perf <span class=\"built_in\">stat</span> -e cycles,instructions -- a.exe</span></span><br><span class=\"line\">2369632 cycles</span><br><span class=\"line\">1725916 instructions # 0,73 insn per cycle</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">或更简单地:</span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">perf <span class=\"built_in\">stat</span> ./a.exe</span></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n<p>问题：</p>\n<p>1.CPU核心时钟和参考时钟的区别？</p>\n<p>2.当你提高频率时， IPC（每个周期内的指令数）是上升、下降还是保持不变？</p>\n<p>3.Roofline 性能模型是一个以吞吐量为导向的性能模型</p>\n<p>硬件有两个主要限制：计算速度 (峰值计算性能， FLOPS) 和数据移动速度 (峰值内存带宽， GB&#x2F;s)。</p>\n<p>算术强度 (Arithmetic Intensity, AI) 是 FLOPS 和字节之间的比率</p>\n<img src=\"/Users/rockyliu/Documents/Roofline.png\" alt=\"image-20250805172347808\" style=\"zoom:67%;\" />\n\n<p>图 中的 roofline 图将两个应用程序 A 和 B 的性能与硬件限制进行了对比。应用程序 A 的运算强度较低，其性能受内存带宽限制，应用程序 B 的计算密集型程度更高，因此不会受到内存瓶颈的太大影响。</p>\n<h2 id=\"5-参考文献\"><a href=\"#5-参考文献\" class=\"headerlink\" title=\"5.参考文献\"></a>5.参考文献</h2><p>1.<a href=\"https://jackiedinh8.medium.com/cpu-performance-analysis-1e8f90ad2d94\">CPU Performance Analysis</a></p>\n<p>2.<a href=\"https://miro.medium.com/v2/resize:fit:640/format:webp/1*KMwBdGSYyB6F64mof-O7Lw.png\">《Performance Analysis and Tuning on Modern CPU》</a></p>\n","text":"1.引言《Processor Microarchitecture An Implementation Perspective》 链接：https://dl.ic...","permalink":"/post/CPU硬件架构解析","photos":[],"count_time":{"symbolsCount":"12k","symbolsTime":"11 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E5%BC%95%E8%A8%80\"><span class=\"toc-text\">1.引言</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-2-CPU%E5%BE%AE%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">1.2 CPU微体系结构</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-2-1-%E5%BE%AE%E6%9E%B6%E6%9E%84%E5%88%86%E7%B1%BB\"><span class=\"toc-text\">1.2.1 微架构分类</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\"><span class=\"toc-text\"></span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-X86\"><span class=\"toc-text\">2.X86</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-1-Intel\"><span class=\"toc-text\">2.1 Intel</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-1-1-%E4%BA%A7%E5%93%81%E8%B7%AF%E6%A0%87%E6%BC%94%E8%BF%9B\"><span class=\"toc-text\">2.1.1 产品路标演进</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-1-2-NUMA-%E6%9E%B6%E6%9E%84\"><span class=\"toc-text\">2.1.2 NUMA 架构</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-2-AMD\"><span class=\"toc-text\">2.2 AMD</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-2-1-%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B\"><span class=\"toc-text\">2.2.1 架构演进</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-3-Chiplet%E6%8A%80%E6%9C%AF\"><span class=\"toc-text\">2.3 Chiplet技术</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-ARM\"><span class=\"toc-text\">3.ARM</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-1-%E7%A1%AC%E4%BB%B6%E6%9E%B6%E6%9E%84\"><span class=\"toc-text\">3.1 硬件架构</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-1-1-%E8%8A%AF%E7%89%87%E7%BB%84%E4%BB%B6\"><span class=\"toc-text\">3.1.1 芯片组件</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-1-2-%E7%BB%84%E4%BB%B6%E5%8D%95%E5%85%83\"><span class=\"toc-text\">3.1.2 组件单元</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90\"><span class=\"toc-text\">4.性能分析</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-1-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86\"><span class=\"toc-text\">4.1 前置知识</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-2-%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF\"><span class=\"toc-text\">4.2 分析思路</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE\"><span class=\"toc-text\">5.参考文献</span></a></li></ol>","author":{"name":"Rocky Liu","slug":"blog-author","avatar":"https://www.sucaisucai.com/all/wukongxiaowukong.html","link":"/","description":"暂时没想好","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"GPU硬件架构解析","uid":"e53b524540553e698f581f4943857291","slug":"GPU硬件架构解析","date":"2025-08-10T10:18:38.000Z","updated":"2025-08-10T10:21:36.612Z","comments":true,"path":"api/articles/GPU硬件架构解析.json","keywords":null,"cover":[],"text":"1. 引言 AI计算需求与硬件挑战 当我尝试训练一个大模型时，通常会遇到两个挑战： 这个模型能否在现有硬件环境中运行？ 需要多长时间才能完成一个数据集的训练？ ...","permalink":"/post/GPU硬件架构解析","photos":[],"count_time":{"symbolsCount":"2.2k","symbolsTime":"2 mins."},"categories":[],"tags":[],"author":{"name":"Rocky Liu","slug":"blog-author","avatar":"https://www.sucaisucai.com/all/wukongxiaowukong.html","link":"/","description":"暂时没想好","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"宕机故障诊断","uid":"845ab074e0d1510ac721db20b5992295","slug":"宕机故障诊断","date":"2025-08-10T08:13:08.000Z","updated":"2025-08-10T08:40:24.869Z","comments":true,"path":"api/articles/宕机故障诊断.json","keywords":null,"cover":null,"text":"","permalink":"/post/宕机故障诊断","photos":[],"count_time":{"symbolsCount":0,"symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"Rocky Liu","slug":"blog-author","avatar":"https://www.sucaisucai.com/all/wukongxiaowukong.html","link":"/","description":"暂时没想好","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}